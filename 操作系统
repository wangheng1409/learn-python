tcp连接：syn k
        syn j,ack k+1
        ack j+1

操作系统：
    更靠近计算机硬件的软件系统，
    管理所有的应用程序
    管理所有的计算机资源
    实现了计算机资源与应用软件之间的操作接口

系统软件与应用软件的区别：是否做计算机资源的调度和控制。

操作系统要求：
    性能：能高效利用计算机资源
    安全：用户和进程共享资源，也需要能独立工作
    易用：接口简单，而富有表现力
    可移植性：要能在不同的操作系统（Linux／Unix／MacOS）／硬件系统中运行（AMD／Inter）

操作系统功能：
    使多个执行单元（进程／线程）可以多路复用cpu时间
    控制和管理多路复用对物理内存和虚拟内存的访问  --虚拟内存：便于组织管理扩展而设计的一种内存管理策略，基于这种管理策略的空间，都可以被操作系统分配作为主存使用。
    实现进程间的通信
    I/O管理，管理与外部设备的通信
    用户界面：命令行解释器（CLI）/图形用户界面（GUI）
    文件管理：管理和组织磁盘上的数据
    系统调用：让应用程序可以使用系统服务（内存／硬盘／网络的编程函数）


操作系统模块划分：
   系统内核：特权模式下执行的代码
   用户空间：非特权模式下执行的代码
   服务／守护进程：后台模式下执行的应用程序
   实用程序：由操作系统提供，而给用户提供的应用程序（编辑器／shell，编译器）
   系统调用：让应用程序可以使用系统服务（内存／硬盘／网络的编程函数）
   c库（libc）：用户级别的函数集合


分层架构：
    功能相似的组件划分为一组
    与每一层交互的只有：向下一层请求服务，向上一层应答服务
    顶层：应用程序
    底层：硬件
    优势：结构良好，接口也定义良好
    劣势：性能稍慢，层次划分有时存在困难
   
    MVC,OSI 7层网络模型
    操作系统：Hardware
            Kernel
            Libearies
            Shell
            Applications
    不同组件如果不在同一层级，增加抽象层 
单体架构系统：
   os被看作单一的大模块：一组程序集合，尽管使用了数据抽象和分层方法，程序之间可以随意调用
   所有数据和代码共享同一内存空间：a.较低的安全机制（驱动间可能引起混乱） b.难以逐步进化升级（一般需要重启操作系统）
   易于实现，较低的性能开销，DOS系统，早期Unix系统


微内核架构系统：
   从内核中删除尽可能多的功能（限制特权模式下的代码量，允许简单的修改和扩展）
   大多数微内核只提供基本的进程和内存管理以及其它服务的消息传递
   可以加强安全和保护（绝大多数服务在用户态完成，而非内核态）
   系统扩展更容易（只需要添加更多应用程序，而不是新建一个内核）
   性能较低（
           几乎所有服务在用户空间，不与内核直接交互（c/s模式通信）
           windows Nt 原本是按微内核架构设计，Nt4.0后改为把部分服务挪到内核态
          ）
   多个OS可以建立在同一个微内核之上（c/s模式）
   

          
        


   
   
    



    





